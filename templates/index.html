<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CFB Attendance Predictor</title>
  <link rel="stylesheet" href="/static/styles.css" />
</head>
<body>
  <header class="top-nav">
    <a class="nav-link nav-link-how" href="{{ url_for('how_page') }}">How?</a>
    <a class="brand" href="{{ url_for('index') }}">Home</a>
    <a class="nav-link nav-link-why" href="{{ url_for('why_page') }}">Why?</a>
  </header>

  <header class="site-header">
    <div class="logo-wrap">
      <img src="/static/cfbLogo.png" alt="CFB Logo" class="logo" />
    </div>
    <p class="sub">Use machine learning to estimate game attendance from a few simple inputs.</p>
  </header>

  <main class="container">
    <section class="card">
      <h2 class="card-title">Model Inputs</h2>

      <!-- Error / success messages -->
      <div id="alert" class="alert" hidden></div>

      <!-- Optional: Home team (for auto capacity/fill) -->
      <div class="field suggest-field">
        <label class="with-tip" for="homeTeam">
          Home Team (optional)
          <span class="tip-icon" tabindex="0" aria-expanded="false" aria-label="What is Home Team?">?</span>
          <span class="tip-content" role="tooltip">
            Type a home team to auto-fill capacity and typical fill rate. Works with aliases like
            <em>Ohio St.</em> or <em>USC</em>. This field is optional.
          </span>
        </label>
        <input id="homeTeam" name="homeTeam"
               autocomplete="off" placeholder="Notre Dame"
               aria-autocomplete="list" aria-haspopup="listbox"
               aria-controls="homeTeamSuggestions" aria-expanded="false" />
        <div id="homeTeamSuggestions" class="suggestions" role="listbox" hidden></div>
      </div>

      <div class="grid">
        <!-- Capacity -->
        <div class="field">
          <label class="with-tip" for="capacity">
            Capacity
            <span class="tip-icon" tabindex="0" aria-expanded="false" aria-label="What is Capacity?">?</span>
            <span class="tip-content" role="tooltip">
              <strong>Capacity</strong> = the stadium’s total number of seats for football.
              Use the latest capacity after renovations. Enter a whole number of people
              (e.g., <code>80795</code>).
            </span>
          </label>
          <input id="capacity" name="capacity" type="number" inputmode="numeric"
                 placeholder="80795" />
        </div>

        <!-- Fill rate -->
        <div class="field">
          <div class="label-line">
            <label class="with-tip" for="fill">
              Fill rate
              <span class="tip-icon" tabindex="0" aria-expanded="false" aria-label="What is Fill rate?">?</span>
              <span class="tip-content" role="tooltip">
                <strong>Fill rate</strong> = average home attendance ÷ capacity over recent seasons.
                Enter a decimal between <code>0.00</code> and <code>1.00</code> (e.g., <code>0.92</code>).
              </span>
            </label>
            <span class="with-tip help-tip">
              <button type="button" class="tip-trigger" aria-expanded="false" aria-label="Need help finding the fill rate?">
                Need help finding fill rate?
              </button>
              <span class="tip-content" role="tooltip">
                <strong>Capacity percent → decimal</strong><br />
                Find the program’s <em>capacity percent</em> in the D1.ticker attendance trends report, then divide by 100 before entering it here. Example: <code>92%</code> → <code>0.92</code>.<br />
                <a href="https://www.d1ticker.com/2024-fbs-attendance-trends/" target="_blank" rel="noopener">Open the reference site ↗</a>
              </span>
            </span>
          </div>
          <input id="fill" name="fill" type="number" step="0.01" min="0" max="1"
                 placeholder="0.92" />
        </div>

        <!-- Wins -->
        <div class="field">
          <label class="with-tip" for="wins">
            Wins
            <span class="tip-icon" tabindex="0" aria-expanded="false" aria-label="What are Wins?">?</span>
            <span class="tip-content" role="tooltip">
              <strong>Wins</strong> = home team wins entering this game (e.g., <code>5</code>).
            </span>
          </label>
          <input id="wins" name="wins" type="number" inputmode="numeric"
                 placeholder="5" />
        </div>

        <!-- Losses -->
        <div class="field">
          <label class="with-tip" for="losses">
            Losses
            <span class="tip-icon" tabindex="0" aria-expanded="false" aria-label="What are Losses?">?</span>
            <span class="tip-content" role="tooltip">
              <strong>Losses</strong> = home team losses entering this game (e.g., <code>2</code>).
            </span>
          </label>
          <input id="losses" name="losses" type="number" inputmode="numeric"
                 placeholder="2" />
        </div>

        <!-- Precipitation -->
        <div class="field">
          <label class="with-tip" for="prcp">
            Precipitation
            <span class="tip-icon" tabindex="0" aria-expanded="false" aria-label="What is Precipitation?">?</span>
            <span class="tip-content" role="tooltip">
              <strong>Precipitation</strong> = expected rain/snow during the game in inches
              (e.g., <code>0.10</code> for a light shower). Use <code>0</code> if none expected.
            </span>
          </label>
          <input id="prcp" name="prcp" type="number" step="0.01" min="0"
                 placeholder="0.10" />
        </div>
      </div>

      <!-- Optional context group -->
      <div class="grid grid-3">
        <div class="field">
          <label class="with-tip" for="rankedStatus">
            Ranked status (optional)
            <span class="tip-icon" tabindex="0" aria-expanded="false" aria-label="What is Ranked status?">?</span>
            <span class="tip-content" role="tooltip">
              Is either team ranked in the latest AP/Coaches poll? Not required for prediction.
            </span>
          </label>
          <select id="rankedStatus" name="rankedStatus">
            <option value="" selected disabled hidden>— select —</option>
            <option value="neither">Neither ranked</option>
            <option value="home">Home ranked</option>
            <option value="away">Away ranked</option>
            <option value="both">Both ranked</option>
          </select>
        </div>

        <div class="field">
          <label class="with-tip" for="rivalry">
            Rivalry game? (optional)
            <span class="tip-icon" tabindex="0" aria-expanded="false" aria-label="What is Rivalry?">?</span>
            <span class="tip-content" role="tooltip">
              Is this a traditional rivalry game? Not required for prediction.
            </span>
          </label>
          <select id="rivalry" name="rivalry">
            <option value="" selected disabled hidden>— select —</option>
            <option value="no">No</option>
            <option value="yes">Yes</option>
          </select>
        </div>

        <div class="field">
          <label class="with-tip" for="kickoffWindow">
            Kickoff window (optional)
            <span class="tip-icon" tabindex="0" aria-expanded="false" aria-label="What is Kickoff window?">?</span>
            <span class="tip-content" role="tooltip">
              Local start time bucket. Not required for prediction.
              <ul style="margin:.5em 0 0 1em; padding:0;">
                <li>Morning: before 1:00 PM</li>
                <li>Afternoon: 1–6 PM</li>
                <li>Night: after 6 PM</li>
              </ul>
            </span>
          </label>
          <select id="kickoffWindow" name="kickoffWindow">
            <option value="" selected disabled hidden>— select —</option>
            <option value="morning">Morning</option>
            <option value="afternoon">Afternoon</option>
            <option value="night">Night</option>
          </select>
        </div>
      </div>

      <div class="actions">
        <button id="predictBtn" type="button" class="btn-primary">Predict attendance</button>
      </div>

      <div id="result" class="result" hidden>
        <div class="result-title">Predicted Attendance</div>
        <div id="predictionValue" class="result-value">—</div>
      </div>
    </section>

    <!-- Model Accuracy Examples (with dates) -->
    <section class="accuracy">
      <h2>Model Accuracy Examples</h2>
      <p class="subtitle">Hand-entered recent games with verified dates. Differences shown as Predicted − Actual.</p>

      <div class="table-wrap">
        <table id="accuracy-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Date</th>
              <th>Game</th>
              <th>Location</th>
              <th>Capacity</th>
              <th>Fill Rate</th>
              <th>Wins–Losses</th>
              <th>Precip</th>
              <th>Actual</th>
              <th>Predicted</th>
              <th>Diff</th>
              <th>Diff %</th>
            </tr>
          </thead>
          <tbody></tbody>
          <tfoot>

          </tfoot>
        </table>
      </div>

      <details class="sources">
        <summary>Sources used for dates & attendance</summary>
        <ul>
          <li>Indiana vs Old Dominion — Aug 30, 2025 (ESPN).  [oai_citation:0‡ESPN.com](https://www.espn.com/college-football/game/_/gameId/401752806/old-dominion-indiana?utm_source=chatgpt.com)</li>
          <li>Notre Dame vs Purdue — Sep 20, 2025; attendance 77,622 (B1G gamebook & ND postgame notes).  [oai_citation:1‡Big Ten Conference](https://bigten.org/api/media/file/PUR%20vs.%20ND%209_20_25.pdf?utm_source=chatgpt.com)</li>
          <li>Illinois at Duke — Sep 6, 2025 (ESPN/Illinois official).  [oai_citation:2‡ESPN.com](https://www.espn.com/college-football/game/_/gameId/401752825/illinois-duke?utm_source=chatgpt.com)</li>
          <li>USC at Illinois — Sep 27, 2025 (USC official).  [oai_citation:3‡USC Athletics](https://usctrojans.com/sports/football/schedule?utm_source=chatgpt.com)</li>
          <li>BYU at Colorado — Sep 27, 2025; attendance 52,265 (Big 12 box/Colorado & BYU pages).  [oai_citation:4‡Big 12 Sports](https://big12sports.com/boxscore.aspx?id=7ltyipP022aUJKmSgYVs3wXi7up73ghniwD5ElWyd07J7BNseBaMQePf0fY%2F3yUP%2FPwVHtaMIr8LMSi5wcXpi24tvAKtIJRe4TFRieI9aQ45XdUrhQ%2FXxOv4uG608G3ST00J3g%2BgULFROe6JDunjEO%2BnFeh6nyAMNJd9KUdG7%2F4%3D&path=football&utm_source=chatgpt.com)</li>
        </ul>
      </details>
    </section>

    <script>
      // ======= Seed data (with dates & locations) =======
      const games = [
        {
          date: "2025-08-30",
          game: "Indiana vs Old Dominion",
          location: "Bloomington, IN",
          capacity: 52929,
          fill: 0.91,
          wins: null, losses: null,
          precip: 0.00,
          actual: 47109,
          predicted: 48080
        },
        {
          date: "2025-09-20",
          game: "Notre Dame vs Purdue",
          location: "Notre Dame Stadium (South Bend, IN)",
          capacity: 80795,
          fill: 1.00,
          wins: 0, losses: 2,
          precip: 0.50,
          actual: 77622,
          predicted: 71353
        },
        {
          date: "2025-09-06",
          game: "Duke vs Illinois (at Duke)",
          location: "Durham, NC",
          capacity: 35018,
          fill: 0.75,
          wins: 1, losses: 0,
          precip: 0.00,
          actual: 23893,
          predicted: 27348
        },
        {
          date: "2025-09-27",
          game: "USC vs Illinois (at Illinois)",
          location: "Champaign, IL",
          capacity: 60670,
          fill: 0.92,
          wins: 3, losses: 1,
          precip: 0.00,
          actual: 60670,
          predicted: 58457
        },
        {
          date: "2025-09-27",
          game: "Colorado vs BYU (at Colorado)",
          location: "Boulder, CO (Folsom Field)",
          capacity: 53750,
          fill: 1.00,
          wins: 2, losses: 2,
          precip: 0.00,
          actual: 52265,
          predicted: 53750
        }
      ];

      const fmtInt = (n) => n == null ? "" : n.toLocaleString();
      const fmtPct = (x, digits = 0) => (x * 100).toFixed(digits) + "%";
      const fmtPrecip = (x) => x == null ? "" : Number(x).toFixed(2);
      const fmtDate = (iso) => {
        if (!iso) return "";
        const date = new Date(`${iso}T00:00:00`);
        if (Number.isNaN(date.getTime())) return iso;
        return new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric', year: 'numeric' }).format(date);
      };

      function renderTable(rows) {
        const tbody = document.querySelector("#accuracy-table tbody");
        tbody.innerHTML = "";
        rows
          .sort((a, b) => (a.date || "").localeCompare(b.date || ""))
          .forEach((r, idx) => {
            const diff = (r.predicted ?? 0) - (r.actual ?? 0);
            const diffPct = (r.actual ? (diff / r.actual) : 0);
            const wl = (r.wins == null || r.losses == null) ? "" : `${r.wins}–${r.losses}`;
            const badgeClass = diff >= 0 ? "badge-up" : "badge-down";

            const tr = document.createElement("tr");
            tr.innerHTML = `
              <td data-label="#"><span>${idx + 1}</span></td>
              <td data-label="Date"><span>${fmtDate(r.date)}</span></td>
              <td data-label="Game"><span>${r.game || ""}</span></td>
              <td data-label="Location"><span>${r.location || ""}</span></td>
              <td data-label="Capacity"><span>${fmtInt(r.capacity)}</span></td>
              <td data-label="Fill Rate"><span>${r.fill != null ? fmtPct(r.fill, 0) : ""}</span></td>
              <td data-label="Wins–Losses"><span>${wl}</span></td>
              <td data-label="Precip"><span>${fmtPrecip(r.precip)}</span></td>
              <td data-label="Actual"><span>${fmtInt(r.actual)}</span></td>
              <td data-label="Predicted"><span>${fmtInt(r.predicted)}</span></td>
              <td data-label="Diff" class="${badgeClass}"><span>${diff >= 0 ? "+" : ""}${fmtInt(diff)}</span></td>
              <td data-label="Diff %" class="${badgeClass}"><span>${(diffPct >= 0 ? "+" : "") + (diffPct * 100).toFixed(1)}%</span></td>
            `;
            tbody.appendChild(tr);
          });
      }

      renderTable(games);
    </script>
  </main>

  <footer class="site-footer">

    <p>© <span id="yr"></span> CFB Attendance Predictor</p>
    <div class="made-by">
      <span class="pill">Made by</span> <strong>Brandon Zettek</strong>
    </div>
  </footer>

  <script>
    // -------------------------- Tooltip tap support --------------------------
    document.addEventListener('DOMContentLoaded', () => {
      const triggers = document.querySelectorAll('.tip-icon, .tip-trigger');
      const tips = document.querySelectorAll('.tip-content');

      const closeAllTips = () => {
        document.querySelectorAll('.with-tip[data-open="true"]').forEach(wrapper => {
          wrapper.dataset.open = 'false';
          wrapper.classList.remove('tip-open');
        });
        document.querySelectorAll('.tip-icon[aria-expanded="true"], .tip-trigger[aria-expanded="true"]').forEach(trigger => {
          trigger.setAttribute('aria-expanded', 'false');
        });
      };

      triggers.forEach(trigger => {
        const wrapper = trigger.closest('.with-tip');
        if (trigger.tagName !== 'BUTTON') {
          trigger.setAttribute('role', 'button');
        }
        if (wrapper) {
          wrapper.dataset.open = 'false';
          wrapper.classList.remove('tip-open');
        }

        const toggle = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const wasOpen = trigger.getAttribute('aria-expanded') === 'true';
          closeAllTips();
          if (!wasOpen) {
            trigger.setAttribute('aria-expanded', 'true');
            if (wrapper) {
              wrapper.dataset.open = 'true';
              wrapper.classList.add('tip-open');
            }
          }
        };

        trigger.addEventListener('click', (e) => {
          if (trigger.dataset.touchSkip === 'true') {
            trigger.dataset.touchSkip = 'false';
            return;
          }
          toggle(e);
        });

        trigger.addEventListener('touchend', (e) => {
          trigger.dataset.touchSkip = 'true';
          toggle(e);
        }, { passive: false });

        if (trigger.tagName !== 'BUTTON') {
          trigger.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              toggle(e);
            }
          });
          trigger.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
              e.preventDefault();
            }
          });
        }
      });

      tips.forEach(content => {
        content.addEventListener('click', (e) => e.stopPropagation());
      });

      document.addEventListener('click', closeAllTips);
    });

    // -------------------------- Helpers --------------------------
    const $ = sel => document.querySelector(sel);
    const alertBox = $('#alert');
    const setAlert = (msg, type='error') => {
      alertBox.textContent = msg || '';
      alertBox.className = 'alert ' + (type === 'error' ? 'error' : 'info');
      alertBox.hidden = !msg;
    };

    // Clear all placeholders once user starts typing anywhere
    let placeholdersCleared = false;
    const clearAllPlaceholders = () => {
      if (placeholdersCleared) return;
      document.querySelectorAll('input[placeholder], select')
        .forEach(el => { el.placeholder = ''; });
      placeholdersCleared = true;
    };

    // Attach a single input handler to clear placeholders on first user action
    document.addEventListener('input', clearAllPlaceholders, { once: true });

    const bindMobileFocusScroll = () => {
      const controls = document.querySelectorAll('input, select');
      controls.forEach(control => {
        control.addEventListener('focus', () => {
          if (window.matchMedia('(max-width: 640px)').matches) {
            window.requestAnimationFrame(() => {
              control.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
            });
          }
        });
      });
    };

    bindMobileFocusScroll();

    // -------------------------- Load teams for datalist --------------------------
    const homeTeamInput = $('#homeTeam');
    const homeTeamSuggestions = $('#homeTeamSuggestions');
    const capacityInput = $('#capacity');
    const fillInput = $('#fill');

    const suggestionLimit = 8;
    let teamOptions = [];
    const teamTokensMap = new Map();
    let suggestionItems = [];
    let activeSuggestion = -1;

    const setActiveSuggestion = (index) => {
      activeSuggestion = index;
      suggestionItems.forEach((item, idx) => {
        const isActive = idx === index;
        item.setAttribute('aria-selected', String(isActive));
        if (isActive) {
          item.scrollIntoView({ block: 'nearest' });
          homeTeamInput.setAttribute('aria-activedescendant', item.id);
        }
      });
      if (index < 0) {
        homeTeamInput.removeAttribute('aria-activedescendant');
      }
    };

    const hideSuggestions = () => {
      homeTeamSuggestions.hidden = true;
      homeTeamSuggestions.innerHTML = '';
      homeTeamInput.setAttribute('aria-expanded', 'false');
      suggestionItems = [];
      setActiveSuggestion(-1);
    };

    const applySuggestion = (value) => {
      homeTeamInput.value = value;
      clearAllPlaceholders();
      hideSuggestions();
      doLookup(value);
      homeTeamInput.focus();
    };

    const renderSuggestions = (matches) => {
      if (!matches || !matches.length) {
        hideSuggestions();
        return;
      }

      homeTeamSuggestions.innerHTML = '';
      matches.forEach((name, idx) => {
        const option = document.createElement('button');
        option.type = 'button';
        option.className = 'suggestion-item';
        option.id = `home-team-option-${idx}`;
        option.setAttribute('role', 'option');
        option.setAttribute('aria-selected', 'false');
        option.dataset.value = name;
        option.textContent = name;
        option.addEventListener('pointerdown', (event) => event.preventDefault());
        option.addEventListener('mousedown', (event) => event.preventDefault());
        option.addEventListener('click', () => applySuggestion(name));
        homeTeamSuggestions.appendChild(option);
      });

      suggestionItems = Array.from(homeTeamSuggestions.querySelectorAll('.suggestion-item'));
      homeTeamSuggestions.hidden = false;
      homeTeamInput.setAttribute('aria-expanded', 'true');
      setActiveSuggestion(-1);
    };

    const tokenize = (text) => (text.toLowerCase().match(/[a-z0-9]+/g) || []);

    const getTeamTokens = (name) => {
      if (!teamTokensMap.has(name)) {
        teamTokensMap.set(name, tokenize(name));
      }
      return teamTokensMap.get(name);
    };

    const filterTeams = (query) => {
      const rawTokens = tokenize(query);
      const significant = rawTokens.filter(tok => {
        return teamOptions.some(name => {
          const tokens = getTeamTokens(name);
          return tokens.some(nt => nt.startsWith(tok));
        });
      });

      const tokens = significant.length
        ? significant
        : rawTokens.length
          ? [rawTokens[rawTokens.length - 1]]
          : [];

      if (!tokens.length) {
        return teamOptions.slice(0, suggestionLimit);
      }

      return teamOptions
        .filter(name => {
          const nameTokens = getTeamTokens(name);
          return tokens.every(tok =>
            nameTokens.some(nt => nt.startsWith(tok))
          );
        })
        .slice(0, suggestionLimit);
    };

    fetch('/api/teams')
      .then(r => r.ok ? r.json() : [])
      .then(arr => {
        if (Array.isArray(arr)) {
          teamOptions = arr;
          teamTokensMap.clear();
          teamOptions.forEach(name => teamTokensMap.set(name, tokenize(name)));
          if (document.activeElement === homeTeamInput) {
            renderSuggestions(filterTeams(homeTeamInput.value));
          }
        }
      })
      .catch(() => { /* ignore */ });

    // -------------------------- Autofill on every keystroke --------------------------

    const markManual = el => {
      el.dataset.autofill = 'manual';
    };

    [capacityInput, fillInput].forEach(el => {
      el.addEventListener('input', () => {
        if (el.value.trim() === '') {
          delete el.dataset.autofill;
        } else {
          markManual(el);
        }
      });
    });

    let inflight = 0;
    const doLookup = (name) => {
      if (!name || name.trim().length < 1) return;
      const ticket = ++inflight;
      fetch('/api/team?name=' + encodeURIComponent(name.trim()))
        .then(r => r.ok ? r.json() : {})
        .then(data => {
          if (ticket !== inflight) return; // drop stale response
          if (data && data.team) {
            const canUpdateCapacity = capacityInput.dataset.autofill !== 'manual' || capacityInput.value.trim() === '';
            const canUpdateFill = fillInput.dataset.autofill !== 'manual' || fillInput.value.trim() === '';

            if (Number.isFinite(+data.capacity) && canUpdateCapacity) {
              capacityInput.value = String(parseInt(data.capacity, 10));
              capacityInput.dataset.autofill = 'auto';
            }
            if (Number.isFinite(+data.fill) && canUpdateFill) {
              const clampedFill = Math.max(0, Math.min(1, Number(data.fill)));
              fillInput.value = clampedFill.toFixed(2);
              fillInput.dataset.autofill = 'auto';
            }
          }
        })
        .catch(() => { /* ignore */ });
    };

    homeTeamInput.addEventListener('input', (e) => {
      const value = e.target.value;
      clearAllPlaceholders();
      doLookup(value);
      if (teamOptions.length) {
        renderSuggestions(filterTeams(value));
      }
    });

    homeTeamInput.addEventListener('focus', (e) => {
      if (teamOptions.length) {
        renderSuggestions(filterTeams(e.target.value));
      }
    });

    homeTeamInput.addEventListener('blur', () => {
      window.requestAnimationFrame(() => {
        if (!homeTeamSuggestions.contains(document.activeElement)) {
          hideSuggestions();
        }
      });
    });

    homeTeamInput.addEventListener('keydown', (e) => {
      if (homeTeamSuggestions.hidden || !suggestionItems.length) return;

      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        e.preventDefault();
        const delta = e.key === 'ArrowDown' ? 1 : -1;
        const nextIndex = (activeSuggestion + delta + suggestionItems.length) % suggestionItems.length;
        setActiveSuggestion(nextIndex);
      } else if (e.key === 'Enter') {
        if (activeSuggestion >= 0 && suggestionItems[activeSuggestion]) {
          e.preventDefault();
          applySuggestion(suggestionItems[activeSuggestion].dataset.value);
        }
      } else if (e.key === 'Escape') {
        hideSuggestions();
      }
    });

    document.addEventListener('click', (e) => {
      if (!homeTeamSuggestions.hidden && !homeTeamSuggestions.contains(e.target) && e.target !== homeTeamInput) {
        hideSuggestions();
      }
    });

    // -------------------------- Validation + Predict --------------------------
    const winsInput   = $('#wins');
    const lossesInput = $('#losses');
    const prcpInput   = $('#prcp');

    const predictBtn = $('#predictBtn');
    const resultWrap = $('#result');
    const predictionValue = $('#predictionValue');

    const validNumber = (v) => v !== '' && !isNaN(+v);

    function validateRequired() {
      const missing = [];
      if (!validNumber(capacityInput.value)) missing.push('Capacity');
      if (!validNumber(fillInput.value))     missing.push('Fill rate');
      if (!validNumber(winsInput.value))     missing.push('Wins');
      if (!validNumber(lossesInput.value))   missing.push('Losses');
      if (!validNumber(prcpInput.value))     missing.push('Precipitation');

      if (missing.length) {
        setAlert('Please provide: ' + missing.join(', ') + '.', 'error');
        return false;
      }
      // extra checks
      const fillVal = parseFloat(fillInput.value);
      if (fillVal < 0 || fillVal > 1) {
        setAlert('Fill rate must be between 0.00 and 1.00.', 'error');
        return false;
      }
      setAlert('');
      return true;
    }

    predictBtn.addEventListener('click', () => {
      if (!validateRequired()) return;

      const payload = {
        features: [
          Number(capacityInput.value),
          Math.max(0, Math.min(1, Number(fillInput.value))),
          Number(winsInput.value),
          Number(lossesInput.value),
          Number(prcpInput.value)
        ],
        extras: {
          homeTeam: homeTeamInput.value || undefined,
          rankedStatus: $('#rankedStatus').value || undefined,
          rivalry: $('#rivalry').value || undefined,
          kickoffWindow: $('#kickoffWindow').value || undefined
        }
      };

      predictBtn.disabled = true;
      predictBtn.textContent = 'Predicting…';

      fetch('/api/predict', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload)
      })
      .then(r => r.json())
      .then(data => {
        if (data && typeof data.prediction === 'number') {
          resultWrap.hidden = false;
          predictionValue.textContent = data.prediction.toLocaleString();
        } else if (data && data.error) {
          setAlert(data.error, 'error');
          resultWrap.hidden = true;
        } else {
          setAlert('Unexpected response from server.', 'error');
          resultWrap.hidden = true;
        }
      })
      .catch(() => {
        setAlert('Network error. Please try again.', 'error');
        resultWrap.hidden = true;
      })
      .finally(() => {
        predictBtn.disabled = false;
        predictBtn.textContent = 'Predict attendance';
      });
    });

    // Footer year
    document.getElementById('yr').textContent = new Date().getFullYear();
  </script>
</body>
</html>
